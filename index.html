<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Torii Tunnel + Stone Path + Large Lantern + Shooting Star + Video Sphere BG</title>
  <style>
    /* 全画面表示 */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background-color: #000;
    }
    #bg-canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: block;
    }
    /* 最前面のUI例 (必要に応じてCSSを加えてください) */
    header, main, footer {
      position: relative;
      z-index: 9999;
      color: #fff;
      font-family: sans-serif;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 2rem;
      background: rgba(0,0,0,0.2);
    }
    .hero {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      max-width: 600px;
    }
  </style>
</head>
<body>

<header>
  <h1>My Portfolio</h1>
</header>

<div class="hero">
  <h2>Welcome!</h2>
  <p>Video BG is back to better quality, plus bigger Lanterns.</p>
</div>

<main>
  <!-- コンテンツ例 -->
</main>

<footer>
  <!-- フッター例 -->
</footer>

<!-- Three.js -->
<canvas id="bg-canvas"></canvas>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
/******************************************************
 * シーン & カメラ & レンダラー
 ******************************************************/
const canvas = document.getElementById('bg-canvas');
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 1.5, 5);

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/******************************************************
 * 1) 背景用の球体 & 動画テクスチャ (MeshBasicMaterial)
 *    -> ライトの影響を受けず、動画本来の画質を反映
 ******************************************************/
const video = document.createElement('video');
video.src = 'Serene_Starlit_Lake.mp4';  // 同フォルダ内にあると仮定
video.loop = true;
video.muted = true;
video.playsInline = true;
video.autoplay = true;
video.play().catch(err => console.warn('Video play error:', err));

const videoTexture = new THREE.VideoTexture(video);
// フィルタ設定(必要に応じて)
videoTexture.minFilter = THREE.LinearFilter;
videoTexture.magFilter = THREE.LinearFilter;

const videoMaterial = new THREE.MeshBasicMaterial({
  map: videoTexture,
  side: THREE.BackSide
});

const sphereGeo = new THREE.SphereGeometry(500, 32, 32);
const sphereMesh = new THREE.Mesh(sphereGeo, videoMaterial);
// 必要なら回転
sphereMesh.rotation.y = 0; 
scene.add(sphereMesh);

/******************************************************
 * 2) ライティング (最小限)
 ******************************************************/
// 環境光
const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
scene.add(ambientLight);

// ディレクショナルライト (月光イメージ)
const moonLight = new THREE.DirectionalLight(0xffffff, 0.4);
moonLight.position.set(10, 20, 10);
moonLight.castShadow = true;
scene.add(moonLight);

/******************************************************
 * 3) 石畳
 ******************************************************/
const textureLoader = new THREE.TextureLoader();
const stoneTexture = textureLoader.load('stone_floor.jpg');
const stoneNormal = textureLoader.load('stone_floor_normal.jpg');

stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
stoneNormal.wrapS = stoneNormal.wrapT = THREE.RepeatWrapping;
stoneTexture.repeat.set(2, 50);
stoneNormal.repeat.set(2, 50);

const stoneGeo = new THREE.PlaneGeometry(3, 300);
const stoneMat = new THREE.MeshStandardMaterial({
  map: stoneTexture,
  normalMap: stoneNormal,
  roughness: 0.8,
  metalness: 0
});
const stonePlane = new THREE.Mesh(stoneGeo, stoneMat);
stonePlane.rotation.x = -Math.PI / 2;
stonePlane.receiveShadow = true;
scene.add(stonePlane);

/******************************************************
 * 4) 鳥居トンネル
 ******************************************************/
const toriiCount = 50;
const toriiSpacing = 3;
const toriiArray = [];

function createTorii() {
  const toriiGroup = new THREE.Group();

  // シンプルに見せる例 (PhongMaterial)
  const pillarMat = new THREE.MeshPhongMaterial({ color: 0xcc0033 });

  const pillarGeo = new THREE.BoxGeometry(0.1, 2, 0.1);
  const pillarLeft = new THREE.Mesh(pillarGeo, pillarMat);
  pillarLeft.position.set(-0.5, 1, 0);
  pillarLeft.castShadow = true;
  toriiGroup.add(pillarLeft);

  const pillarRight = new THREE.Mesh(pillarGeo, pillarMat);
  pillarRight.position.set(0.5, 1, 0);
  pillarRight.castShadow = true;
  toriiGroup.add(pillarRight);

  const crossbarGeo = new THREE.BoxGeometry(1.4, 0.1, 0.3);
  const crossbar = new THREE.Mesh(crossbarGeo, pillarMat);
  crossbar.position.set(0, 2, 0);
  crossbar.castShadow = true;
  toriiGroup.add(crossbar);

  const topbarGeo = new THREE.BoxGeometry(1.6, 0.05, 0.2);
  const topbar = new THREE.Mesh(topbarGeo, pillarMat);
  topbar.position.set(0, 2.1, 0);
  topbar.rotation.z = 0.02;
  topbar.castShadow = true;
  toriiGroup.add(topbar);

  return toriiGroup;
}
for (let i = 0; i < toriiCount; i++) {
  const torii = createTorii();
  torii.position.z = -i * toriiSpacing;
  scene.add(torii);
  toriiArray.push(torii);
}

/******************************************************
 * 5) 大きいコムローイ(ランタン)
 ******************************************************/
function createLantern() {
  const lanternGroup = new THREE.Group();

  // （以前投稿した "大きい" ジオメトリ）
  const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.45, 1.2, 16, 1, true);
  const bodyMaterial = new THREE.MeshPhongMaterial({
    color: 0xfffaf0,
    emissive: 0xff4400,
    emissiveIntensity: 0.3,
    transparent: true,
    opacity: 0.9,
    side: THREE.DoubleSide
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);

  // 上部リング
  const ringGeoTop = new THREE.TorusGeometry(0.6, 0.03, 8, 24);
  const ringMat = new THREE.MeshPhongMaterial({ 
    color: 0x8b4513, 
    emissive: 0x3d2b1f, 
    emissiveIntensity: 0.2 
  });
  const topRing = new THREE.Mesh(ringGeoTop, ringMat);
  topRing.position.y = 0.6;

  // 下部リング
  const ringGeoBottom = new THREE.TorusGeometry(0.45, 0.03, 8, 24);
  const bottomRing = new THREE.Mesh(ringGeoBottom, ringMat);
  bottomRing.position.y = -0.6;

  // 燃料部
  const fuelGeo = new THREE.CylinderGeometry(0.075, 0.075, 0.15, 8);
  const fuelMat = new THREE.MeshPhongMaterial({ color: 0xd2691e });
  const fuel = new THREE.Mesh(fuelGeo, fuelMat);
  fuel.position.y = -0.65;

  // 火
  const fireGeo = new THREE.SphereGeometry(0.22, 8, 8);
  const fireMat = new THREE.MeshPhongMaterial({
    color: 0xff4500,
    emissive: 0xff4500,
    emissiveIntensity: 1,
    transparent: true,
    opacity: 0.7
  });
  const fire = new THREE.Mesh(fireGeo, fireMat);
  fire.position.y = -0.55;

  // 光源 (ランタン内部)
  const fireLight = new THREE.PointLight(0xff6b1a, 1, 3);
  fireLight.position.set(0, -0.55, 0);

  // 縦支柱4本
  for (let i = 0; i < 4; i++) {
    const supportGeo = new THREE.CylinderGeometry(0.015, 0.015, 1.2, 4);
    const support = new THREE.Mesh(supportGeo, ringMat);
    const angle = (Math.PI * 2 * i) / 4;
    support.position.set(Math.cos(angle)*0.5, 0, Math.sin(angle)*0.5);
    lanternGroup.add(support);
  }

  lanternGroup.add(body, topRing, bottomRing, fuel, fire, fireLight);
  return lanternGroup;
}

const lanterns = [];
const lanternCount = 50;
for (let i = 0; i < lanternCount; i++) {
  const lantern = createLantern();
  lantern.position.set(
    (Math.random() - 0.5) * 60, // X
    Math.random() * 20,        // Y
    Math.random() * -200 + 10  // Z
  );
  lantern.rotation.x = (Math.random() - 0.5)*0.2;
  lantern.rotation.z = (Math.random() - 0.5)*0.2;

  lantern.userData.velocity = {
    y: Math.random()*0.02 + 0.01,
    x: Math.random()*0.005 - 0.0025,
    z: Math.random()*0.005 - 0.0025
  };
  lantern.userData.swing = {
    x: Math.random()*Math.PI*2,
    z: Math.random()*Math.PI*2,
    speedX: 0.01 + Math.random()*0.01,
    speedZ: 0.01 + Math.random()*0.01,
    amplitudeX: 0.05,
    amplitudeZ: 0.05
  };
  lanterns.push(lantern);
  scene.add(lantern);
}

/******************************************************
 * 6) 流れ星(パーティクル)
 ******************************************************/
const meteorCount = 30;
const meteorPositions = new Float32Array(meteorCount * 3);
const meteorVelocities = [];
for (let i = 0; i < meteorCount; i++) {
  meteorPositions[i*3+0] = (Math.random() - 0.5)*200;
  meteorPositions[i*3+1] = Math.random()*30 + 10;
  meteorPositions[i*3+2] = (Math.random() - 0.5)*200;

  meteorVelocities.push({
    x: (Math.random() - 0.5)*0.2,
    y: -(Math.random()*0.05 + 0.02),
    z: (Math.random() - 0.5)*0.2
  });
}
const meteorGeo = new THREE.BufferGeometry();
meteorGeo.setAttribute('position', new THREE.BufferAttribute(meteorPositions, 3));

const meteorMat = new THREE.PointsMaterial({
  color: 0xffffff, 
  size: 0.5, 
  transparent: true
});
const meteorPoints = new THREE.Points(meteorGeo, meteorMat);
scene.add(meteorPoints);

/******************************************************
 * 7) アニメーション
 ******************************************************/
let speed = 0.03;    
const reuseDistance = toriiSpacing * toriiCount;

function updateFire(lantern) {
  const fire = lantern.children.find(obj =>
    obj.material && obj.material.emissive && obj.material.emissive.getHex() === 0xff4500
  );
  if (fire) {
    fire.scale.x = 1 + Math.sin(performance.now()*0.01)*0.1;
    fire.scale.y = 1 + Math.sin(performance.now()*0.015)*0.1;
    fire.scale.z = 1 + Math.sin(performance.now()*0.012)*0.1;
    fire.material.emissiveIntensity = 0.8 + Math.sin(performance.now()*0.01)*0.2;
  }
}

function animate() {
  requestAnimationFrame(animate);

  // 鳥居トンネル無限ループ
  camera.position.z -= speed;
  toriiArray.forEach(torii => {
    if (torii.position.z - camera.position.z > 10) {
      torii.position.z -= reuseDistance;
    }
  });

  // ランタン浮遊
  lanterns.forEach(lantern => {
    lantern.position.y += lantern.userData.velocity.y;
    lantern.position.x += lantern.userData.velocity.x;
    lantern.position.z += lantern.userData.velocity.z;

    const swing = lantern.userData.swing;
    swing.x += swing.speedX;
    swing.z += swing.speedZ;
    lantern.rotation.x = Math.sin(swing.x)*swing.amplitudeX;
    lantern.rotation.z = Math.sin(swing.z)*swing.amplitudeZ;

    updateFire(lantern);

    // 上に行きすぎたらリセット
    if (lantern.position.y > 60) {
      lantern.position.set(
        (Math.random() - 0.5)*60,
        -10,
        Math.random()*-200 + 10
      );
    }
  });

  // 流れ星(パーティクル) 更新
  const posArr = meteorGeo.attributes.position.array;
  for (let i = 0; i < meteorCount; i++) {
    posArr[i*3+0] += meteorVelocities[i].x;
    posArr[i*3+1] += meteorVelocities[i].y;
    posArr[i*3+2] += meteorVelocities[i].z;

    if (posArr[i*3+1] < -5) {
      posArr[i*3+0] = (Math.random()-0.5)*200;
      posArr[i*3+1] = Math.random()*30 + 10;
      posArr[i*3+2] = (Math.random()-0.5)*200;
      meteorVelocities[i].x = (Math.random() - 0.5)*0.2;
      meteorVelocities[i].y = -(Math.random()*0.05 + 0.02);
      meteorVelocities[i].z = (Math.random() - 0.5)*0.2;
    }
  }
  meteorGeo.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>

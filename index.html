<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Torii Tunnel + Stone Path + Lanterns + Refined Smaller Buttons</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #000;
    }
    #bg-canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: block;
    }
    /* Optional page sections for anchor links */
    .section {
      position: absolute;
      left: 10%;
      width: 80%;
      height: 100vh;
      background: rgba(0,0,0,0.3);
      color: #fff;
      padding: 2rem;
      font-family: "Open Sans", sans-serif;
    }
    #about { top: 150vh; }
    #learning { top: 250vh; }
    #projects { top: 350vh; }
    #contact { top: 450vh; }
  </style>
  <!-- Google Fonts: Open Sans -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap"
    rel="stylesheet"
  />
</head>
<body>
  <canvas id="bg-canvas"></canvas>

  <!-- Example page anchors -->
  <div id="about" class="section">
    <h1>ABOUT ME</h1>
    <p>... put your biography here ...</p>
  </div>
  <div id="learning" class="section">
    <h1>LEARNING</h1>
    <p>... put your learning topics here ...</p>
  </div>
  <div id="projects" class="section">
    <h1>PROJECTS</h1>
    <p>... put your projects here ...</p>
  </div>
  <div id="contact" class="section">
    <h1>CONTACT</h1>
    <p>... put your contact details here ...</p>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let raycaster, mouse;
    let toriiArray = [];
    const toriiCount = 40;
    const toriiSpacing = 3;
    const reuseDistance = toriiSpacing * toriiCount;
    let speed = 0.03;

    // 4 color variations + button text/link (English)
    const toriiData = [
      { color: 0x990000, text: "ABOUT ME",    link: "#about" },
      { color: 0x000099, text: "LEARNING",    link: "#learning" },
      { color: 0x999900, text: "PROJECTS",    link: "#projects" },
      { color: 0x009900, text: "CONTACT",     link: "#contact" },
    ];

    // Lantern data
    let lanterns = [];
    const lanternCount = 20;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.5, 5);

      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('bg-canvas'),
        antialias: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      window.addEventListener('resize', onWindowResize);
      document.addEventListener('click', onClick);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(5, 10, 5);
      dirLight.castShadow = true;
      scene.add(dirLight);

      // Stone path
      createStonePath();

      // Lanterns
      createLanterns();

      // Torii tunnel + Buttons
      for (let i = 0; i < toriiCount; i++) {
        const index = i % 4;
        const tData = toriiData[index];
        const toriiGroup = createToriiGroup(tData.color, tData.text, tData.link);
        toriiGroup.position.z = -i * toriiSpacing;
        scene.add(toriiGroup);
        toriiArray.push(toriiGroup);
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(scene.children, true);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (obj.userData.isToriiButton) {
          const link = obj.userData.link;
          if (link) location.href = link;
        }
      }
    }

    // Torii + smaller button plane
    function createToriiGroup(colorHex, buttonText, buttonLink) {
      const group = new THREE.Group();

      // Torii
      const mat = new THREE.MeshPhongMaterial({ color: colorHex });
      const pillarGeo = new THREE.BoxGeometry(0.1, 2, 0.1);

      const left = new THREE.Mesh(pillarGeo, mat);
      left.position.set(-0.5, 1, 0);
      group.add(left);

      const right = new THREE.Mesh(pillarGeo, mat);
      right.position.set(0.5, 1, 0);
      group.add(right);

      const crossGeo = new THREE.BoxGeometry(1.4, 0.1, 0.3);
      const crossbar = new THREE.Mesh(crossGeo, mat);
      crossbar.position.set(0, 2, 0);
      group.add(crossbar);

      const topGeo = new THREE.BoxGeometry(1.6, 0.05, 0.2);
      const topbar = new THREE.Mesh(topGeo, mat);
      topbar.position.set(0, 2.1, 0);
      topbar.rotation.z = 0.02;
      group.add(topbar);

      // Smaller button
      const btnTexture = createButtonTexture(buttonText, colorHex);
      const btnMat = new THREE.MeshBasicMaterial({
        map: btnTexture,
        transparent: true
      });
      // ~ Slightly smaller plane
      const btnGeo = new THREE.PlaneGeometry(0.5, 0.18);
      const buttonPlane = new THREE.Mesh(btnGeo, btnMat);
      buttonPlane.position.set(0, 1.2, 0.05);
      buttonPlane.userData.isToriiButton = true;
      buttonPlane.userData.link = buttonLink;
      group.add(buttonPlane);

      return group;
    }

    // Refined smaller button texture
    function createButtonTexture(label, colorHex) {
      const canvas = document.createElement('canvas');
      // smaller canvas
      canvas.width = 256;
      canvas.height = 96;
      const ctx = canvas.getContext('2d');

      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // Convert colorHex to RGB
      const c = new THREE.Color(colorHex);
      const r = Math.floor(c.r * 255);
      const g = Math.floor(c.g * 255);
      const b = Math.floor(c.b * 255);

      // Subtle gradient
      const grad = ctx.createLinearGradient(0, 0, w, h);
      // Brighter start, darker end
      grad.addColorStop(0, `rgba(${r+30}, ${g+30}, ${b+30}, 1)`);
      grad.addColorStop(1, `rgba(${r-30}, ${g-30}, ${b-30}, 1)`);

      ctx.fillStyle = grad;
      roundRect(ctx, 0, 0, w, h, 20);
      ctx.fill();

      // Subtle border
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 4;
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      roundRect(ctx, 0, 0, w, h, 20);
      ctx.stroke();

      // Text
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 32px "Open Sans", sans-serif';
      ctx.fillText(label, w/2, h/2);

      return new THREE.CanvasTexture(canvas);
    }

    function roundRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    // Stone path (plane + texture)
    function createStonePath() {
      const loader = new THREE.TextureLoader();
      const stoneTex = loader.load('stone_floor.jpg');
      const stoneNorm = loader.load('stone_floor_normal.jpg');
      stoneTex.wrapS = stoneTex.wrapT = THREE.RepeatWrapping;
      stoneNorm.wrapS = stoneNorm.wrapT = THREE.RepeatWrapping;
      stoneTex.repeat.set(2, 50);
      stoneNorm.repeat.set(2, 50);

      const geo = new THREE.PlaneGeometry(3, 300);
      const mat = new THREE.MeshStandardMaterial({
        map: stoneTex,
        normalMap: stoneNorm,
        roughness: 0.8,
        metalness: 0
      });
      const plane = new THREE.Mesh(geo, mat);
      plane.rotation.x = -Math.PI / 2;
      plane.receiveShadow = true;
      scene.add(plane);
    }

    // Lanterns creation
    function createLanterns() {
      for (let i = 0; i < lanternCount; i++) {
        const ln = createLanternMesh();
        ln.position.set(
          (Math.random()-0.5)*20,
          Math.random()*10,
          (Math.random()-0.5)*-200
        );
        scene.add(ln);
        lanterns.push(ln);
      }
    }

    function createLanternMesh() {
      const group = new THREE.Group();

      const bodyGeo = new THREE.CylinderGeometry(0.4, 0.3, 0.8, 16, 1, true);
      const bodyMat = new THREE.MeshPhongMaterial({
        color: 0xfffaf0,
        emissive: 0xff4400,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);

      const ringGeoTop = new THREE.TorusGeometry(0.4, 0.02, 8, 24);
      const ringMat = new THREE.MeshPhongMaterial({
        color: 0x8b4513,
        emissive: 0x3d2b1f,
        emissiveIntensity: 0.2
      });
      const topRing = new THREE.Mesh(ringGeoTop, ringMat);
      topRing.position.y = 0.4;
      group.add(topRing);

      const ringGeoBtm = new THREE.TorusGeometry(0.3, 0.02, 8, 24);
      const btmRing = new THREE.Mesh(ringGeoBtm, ringMat);
      btmRing.position.y = -0.4;
      group.add(btmRing);

      const fuelGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 8);
      const fuelMat = new THREE.MeshPhongMaterial({ color: 0xd2691e });
      const fuel = new THREE.Mesh(fuelGeo, fuelMat);
      fuel.position.y = -0.45;
      group.add(fuel);

      const fireGeo = new THREE.SphereGeometry(0.15, 8, 8);
      const fireMat = new THREE.MeshPhongMaterial({
        color: 0xff4500,
        emissive: 0xff4500,
        emissiveIntensity: 1,
        transparent: true,
        opacity: 0.7
      });
      const fire = new THREE.Mesh(fireGeo, fireMat);
      fire.position.y = -0.35;
      group.add(fire);

      const fireLight = new THREE.PointLight(0xff6b1a, 1, 3);
      fireLight.position.y = -0.35;
      group.add(fireLight);

      // 4 supports
      for (let i = 0; i < 4; i++) {
        const supGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.8, 4);
        const support = new THREE.Mesh(supGeo, ringMat);
        const angle = (Math.PI*2*i)/4;
        support.position.set(Math.cos(angle)*0.35, 0, Math.sin(angle)*0.35);
        group.add(support);
      }

      // Simple float
      group.userData.velocity = {
        x: (Math.random()*0.02 - 0.01),
        y: (Math.random()*0.01 + 0.005),
        z: (Math.random()*0.02 - 0.01)
      };
      return group;
    }

    function animate() {
      requestAnimationFrame(animate);

      // Camera moves forward
      camera.position.z -= speed;

      // Torii infinite loop
      toriiArray.forEach(torii => {
        if (torii.position.z - camera.position.z > 10) {
          torii.position.z -= reuseDistance;
        }
      });

      // Lanterns float
      lanterns.forEach(ln => {
        ln.position.x += ln.userData.velocity.x;
        ln.position.y += ln.userData.velocity.y;
        ln.position.z += ln.userData.velocity.z;

        if (ln.position.y > 30) {
          ln.position.y = 0;
        }
      });

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
